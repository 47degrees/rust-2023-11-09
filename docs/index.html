<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Rust: An Introduction</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">
		<link rel="stylesheet" href="dist/theme/local.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- Introduction. -->
				<section
						data-background-gradient="linear-gradient(to bottom, #FF474C, #8B47AC)"
						data-background-image="assets/cuddlyferris.svg"
						data-background-size="50%"
						style="text-shadow: 1px 1px 3px #0000f1"
				>
					<p style="font-size: larger; margin-top: 2em; margin-bottom: 3em">
						<span class="rust">Rust</span>: An Introduction
					</p>
					<p style="font-size: medium">
						by <span class="rust" style="text-decoration: line-through">Ferris the Crab</span> Todd Smith<br/>
						Rust Solution Architect<br/>
						Xebia Functional
					</p>
					<aside class="notes">
						{5s}<br>
						&rarr;
					</aside>
				</section>

				<!-- Where Rust is used. -->
				<section>
					<p>Where is <span class="rust">Rust</span> used?</p>
					<ul>
						<li class="fragment fade-left">Backend</li>
						<li class="fragment fade-left">Web</li>
						<li class="fragment fade-left">Mobile</li>
						<li class="fragment fade-left">Embedded</li>
						<li class="fragment fade-left">GUI</li>
						<li class="fragment fade-left">Games</li>
					</ul>
					<aside class="notes">
						Rust is a systems programming language with great ergonomics and sweet
						high-level features, suitable for<br>
						&rarr;<br>
						backend development,<br>
						&rarr;<br>
						web applications,<br>
						&rarr;<br>
						mobile,<br>
						&rarr;<br>
						embedded,<br>
						&rarr;<br>
						graphical user interfaces,<br>
						&rarr;<br>
						and even games.<br>
						{3s}<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Noteworthy features of Rust. -->
				<section>
					<p>Noteworthy features of <span class="rust">Rust</span>:</p>
					<div style="margin-left: 8em">
						<ul style="display: block">
							<li class="fragment fade-left" style="font-size: medium">Imperative execution</li>
						</ul>
						<ul class="fragment fade-left" style="display: block">
							<li style="font-size: medium">Immutability by default</li>
							<li style="font-size: medium">Algebraic data types</li>
							<li style="font-size: medium">Higher-order functions</li>
							<li style="font-size: medium">Type deduction (Hindley-Milner)</li>
							<li style="font-size: medium">Traits (i.e., type classes)</li>
							<li style="font-size: medium">Pattern matching</li>
						</ul>
						<ul style="display: block">
							<li class="fragment fade-left" style="font-size: medium">Top-tier performance</li>
							<li class="fragment fade-left" style="font-size: medium">Type safety</li>
							<li class="fragment fade-left" style="font-size: medium">Memory safety</li>
							<li class="fragment fade-left" style="font-size: medium">Metaprogramming (macros, auto-derive)</li>
							<li
									class="fragment fade-left-highlight-red"
									style="font-size: medium; text-transform: uppercase"
							>
								No garbage collector!
							</li>
						</ul>
					</div>
					<aside class="notes">
						Rust is an<br>
						&rarr;<br>
						imperative language at its core,<br>
						&rarr;<br>
						but borrows a lot of goodness from functional programming. Rust also provides<br>
						&rarr;<br>
						top-notch performance,<br>
						&rarr;<br>
						type safety,<br>
						&rarr;<br>
						and memory safety.<br>
						&rarr;<br>
						Rust supports metaprogramming through attributes and macros.<br>
						&rarr;<br>
						And incredibly, Rust does all of this without a garbage collector.<br>
						{3s}<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Timeline of Rust. -->
				<section>
					<p>Timeline of <span class="rust">Rust</span>:</p>
					<ul>
						<li>
							2006: Created by Graydon Hoare at Mozilla
						</li>
						<li class="fragment fade-left">
							2009: Adopted officially at Mozilla
						</li>
						<li class="fragment fade-left">
							2015: First stable release
						</li>
						<li class="fragment fade-left-highlight-red" style="text-transform: uppercase">
							2022: Linux kernel, baby!
						</li>
						<li class="fragment fade-left">
							2023: Xebia Functional opens Rust service line
						</li>
					</ul>
					<aside class="notes">
						Graydon Hoare created Rust as a personal project in 2006 while working at Mozilla.<br>
						&rarr;<br>
						Mozilla officially adopted the project in 2009, but<br>
						&rarr;<br>
						the first stable release wasn't until May 2015. Since its release, grassroots enthusiasm has brought it to<br>
						Amazon, Meta, Alphabet, Microsoft, and tons of others.<br>
						&rarr;<br>
						Linus even welcomed it into the kernel in December 2022! But the adoption of programming languages is slow,<br>
						yo, so it's only recently that Rust started spreading like wildfire.<br>
						&rarr;<br>
						Now that wildfire has spread to Xebia Functional.<br>
						{suspend}<br>
						{focus on presenter}<br>
						For the next 30 minutes, that wildfire looks like this guy, Todd Smith, the new Rust Solution Architect,
						laying down some Rust basics, so thanks for joining me today. Without further ado, let's see what Rust
						brings to table.<br>
						{resume}<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Memory safety segue. -->
				<section>
					<h1>MEMORY SAFETY</h1>
					<p class="fragment custom fade-blur">(in C ðŸ˜–)</p>
					<aside class="notes">
						There are a lot of things that Rust does the same as other languages, but I want to focus on what Rust does
						<em>differently</em>.<br>
						It's typical to spend a lot of time <em>thinking</em> about data ownership when using a systems programming
						language,<br>
						&rarr;<br>
						but usually the language doesn't have any useful features for <em>actually managing</em> data ownership.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Splint code. -->
				<section data-auto-animate="splint">
					<div class="r-stack">
						<pre><code class="language-cpp" data-trim data-line-numbers data-noescape>
extern /*@only@*/ int* glob;

/*@only@*/ int* f (
	/*@only@*/ int* x,
	int* y,
	int* z
) /*@globals glob@*/
{
	int* m = (int*) malloc(sizeof(int));
	glob = y;
	free(x);
	*m = *x;
	return z;
}
						</code></pre>
					</div>
					<p>Splint</p>
					<aside class="notes">
						Back in the bad old days of C, if you wanted memory safety, you could bust out third-party tools like Splint
						and Valgrind and then instrument your code with cheesy annotations and special wrapper calls.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Splint feedback. -->
				<section data-auto-animate="splint">
					<div class="r-stack">
						<pre style="margin-top: -40px; margin-left: -10px">
							<code class="language-cpp" data-trim data-line-numbers data-noescape>
extern /*@only@*/ int* glob;

/*@only@*/ int* f (
	/*@only@*/ int* x,
	int* y,
	int* z
) /*@globals glob@*/
{
	int* m = (int*) malloc(sizeof(int));
	glob = y;
	free(x);
	*m = *x;
	return z;
}
							</code>
						</pre>
						<pre>
							<code data-trim data-noescape style="background-color: #444444">
> splint only.c
only.c:10: Only storage glob (type int *) not released
	before assignment: glob = y
only.c:1: Storage glob becomes only
only.c:11: Implicitly temp storage y assigned to only:
	glob = y
only.c:12: Dereference of possibly null pointer m: *m
only.c:9: Storage m may become null
only.c:12: Variable x used after being released
only.c:11: Storage x released
only.c:13: Implicitly temp storage z returned as only: z
only.c:13: Fresh storage m not released before return
only.c:9: Fresh storage m allocated
							</code>
						</pre>
					</div>
					<p>Splint</p>
					<aside class="notes">
						But you only got as much support as you paid for with your own effort and diligence; you got nada from the
						compiler. And you still expected to spend hours, days, maybe weeks, in front of transcripts and debuggers.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Possession is 9/10 of the law. -->
				<section data-auto-animate="law">
					<a data-id="image" href="https://commons.wikimedia.org/w/index.php?curid=59794940">
						<img
								src="assets/Hammurabi%20Speaks.png"
								alt="By Mbzt - Own work, CC BY 3.0, https://commons.wikimedia.org/w/index.php?curid=59794940"
								style="width: 50%; height: auto">
					</a>
					<p data-id="lawgiver">Hammurabi the Lawgiver</p>
					<aside class="notes">
						They say that possession is nine tenths of the law,<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Possession is 9/10 of the law. -->
				<section
						data-auto-animate="law"
						data-background-gradient="linear-gradient(to bottom, #FF474C, #8B47AC)"
				>
					<img
							data-id="image"
							src="assets/Ferris%20Speaks.png"
							alt="Ferris Speaks"
							style="width: 50%; height: auto"
					>
					<p data-id="lawgiver"><span style="text-decoration: line-through">Hammurabi</span> <span class="rust">Ferris</span> the Lawgiver</p>
					<aside class="notes">
						but in Rust, it's more like the whole of the law. Rust bakes in all the support that C desperately needs but
						never had. Ownership is built directly into the type system, so type safety <em>is</em> memory safety.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Introducing ownership. -->
				<section>
					<dl>
						<dt>Ownership</dt>
						<dd class="fragment">The <span class="rust">obligation</span> to destroy a value <em>when it goes out of scope</em>.</dd>
					</dl>
					<aside class="notes">
						So, what <em>is</em> ownership, exactly?<br>
						&rarr;<br>
						Well, it's basically the obligation to destroy something when it goes out of scope.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Demonstrate ownership. -->
				<section>
					<pre style="font-size: medium"><code class="language-rust" data-trim data-line-numbers data-noescape>
struct Wrapped&lt;T&gt;(
	T // Owner of some `T`
);

enum Either&lt;A, B&gt; {
	A(A), // Owner of some `A`
	B(B), // Owner of some `B`
}

fn main() {
	let i = 5;            // Owner of `5`
	let w = Wrapped(i);   // Owner of `Wrapped(5)`; `i` still lives
	let a = Either::A(w); // Owner of `Either::A`; `w` destroyed by move
	let _x = f(a);        // Owner of some `Either`; `a` destroyed by move
} // `_x` destroyed by end of block

fn f&lt;A&gt;(
	e: Either&lt;Wrapped&lt;A&gt;, Wrapped&lt;A&gt;&gt;   // Owner of some `Either`
) -&gt; Either&lt;Wrapped&lt;A&gt;, Wrapped&lt;A&gt;&gt; { // Returns ownership of some `Either`
	match e {
		Either::A(a) =&gt; // `a` is owner of `Wrapped`; `e` destroyed by move
			Either::B(a), // Temporary is owner of `Either::B`
		Either::B(b) =&gt; // `a` is owner of `Wrapped`; `e` destroyed by move
			Either::A(b)  // Temporary is owner of `Either::A`
	} // Return ownership of some `Either`
}
					</code></pre>
					<p>Ownership</p>
					<aside class="notes">
						I know that was so 2 minutes ago, but remember how I said that Rust doesn't need a garbage collector?
						Instead, the Rust compiler has a <em>borrow checker</em>, a built-in static analyzer that tracks ownership
						of values. The borrow checker ensures that Rust always knows when to destroy an object. In the vast majority
						of cases, the borrow checker can <em>statically</em> determine where to insert the destructor call; in the
						few cases where it can't, the borrow checker can defer ownership tracking until runtime. There's no escaping
						the borrow checker, and that's a good thing!<br>

						Ownership always accompanies introduction of a value. In other words, when code mentions a literal or
						instantiates a struct or enum, then some variable, formal parameter, field, or temporary becomes the owner
						of the new value. And the owner is responsible for the value's eventual destruction, when the owner goes out
						of scope.<br>

						But the owner can also delegate that responsibility, by assigning the value to another variable or field or
						by giving ownership to another function or method. Whenever you see a punctuation-free type annotation on a
						formal parameter of a function or method signature, it means that the formal parameter assumes ownership of
						the passed value. After giving the value away, the owner becomes defunct â€” it hasn't technically gone out of
						scope, but the compiler will signal an error if you mention it again.<br>

						For simple values, like booleans and numbers, the compiler makes a copy, and the result is two owned values
						â€” one associated with the original binding, one with the new binding.<br>

						For more complex values, passing the value transfers ownership to the new binding. After the transfer, you
						can't use the original binding anymore â€” no takebacks!<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Deriving Copy. -->
				<section>
					<div class="r-stack">
						<img
								class="fragment major-fade-out"
								src="assets/Spy%20Shhh.png"
								alt="Spy Shhh"
								style="width: 60%; height: auto"
								data-fragment-index="1"
						>
						<pre class="fragment" style="font-size: medium" data-fragment-index="1">
							<code class="language-rust" data-trim data-line-numbers data-noescape>
#[derive(Copy)] // Instances will be copied rather than moved
struct Point3D {
	x: f64,
	y: f64,
	z: f64
}
							</code>
						</pre>
					</div>
					<p>Deriving the <code>Copy</code> trait</p>
					<aside class="notes">
						Full disclosure: you can opt into copying for your own types, but that's out of scope right now;<br>
						&rarr;<br>
						I need to leave stuff for future talks, capisce?<br>
						{3s}<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Demonstrate ownership, redux. -->
				<section>
					<pre style="font-size: medium"><code class="language-rust" data-trim data-line-numbers data-noescape>
struct Wrapped&lt;T&gt;(
	T // Owner of some `T`
);

enum Either&lt;A, B&gt; {
	A(A), // Owner of some `A`
	B(B), // Owner of some `B`
}

fn main() {
	let i = 5;            // Owner of `5`
	let w = Wrapped(i);   // Owner of `Wrapped(5)`; `i` still lives
	let a = Either::A(w); // Owner of `Either::A`; `w` destroyed by move
	let _x = f(a);        // Owner of some `Either`; `a` destroyed by move
} // `_x` destroyed by end of block

fn f&lt;A&gt;(
	e: Either&lt;Wrapped&lt;A&gt;, Wrapped&lt;A&gt;&gt;   // Owner of some `Either`
) -&gt; Either&lt;Wrapped&lt;A&gt;, Wrapped&lt;A&gt;&gt; { // Returns ownership of some `Either`
	match e {
		Either::A(a) =&gt; // `a` is owner of `Wrapped`; `e` destroyed by move
			Either::B(a), // Temporary is owner of `Either::B`
		Either::B(b) =&gt; // `a` is owner of `Wrapped`; `e` destroyed by move
			Either::A(b)  // Temporary is owner of `Either::A`
	} // Return ownership of some `Either`
}
					</code></pre>
					<p>Ownership</p>
					<aside class="notes">
						Anyway, taken together, these rules mean that every value has exactly one owner. And since the owner has the
						obligation to destroy the value, it means that each value will be destroyed at most one time.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Double free in C. -->
				<section>
					<pre><code class="language-cpp" data-trim data-line-numbers data-noescape>
int* x = (int*) malloc(sizeof(int)); // Allocate
free(x);                             // Single free - good
free(x);                             // Double free - bad
					</code></pre>
					<p>C loves double free &mdash; no error ðŸ¤¦</p>
					<aside class="notes">
						If you've spent a lot of time with C or C++, you've probably already drawn the conclusion: by enforcing
						linearity of ownership,<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Double free in Rust. -->
				<section>
					<pre><code class="language-rust" data-trim data-line-numbers data-noescape data-ln-start-from="2">
let x = SomeStruct::default(); // Allocate
drop(x);                       // Single free - good
drop(x);                       // Double free - forbidden!
					</code></pre>
					<pre class="console" style="font-size: medium">
<span class="command">âžœ cargo</span> build
   <span class="command">Compiling</span> double-free v0.1.0 (/double-free)
<span class="error">error[E0382]</span>: use of moved value: `x`
 <span class="advice">--></span> double-free/src/main.rs:4:10
  <span class="advice">|</span>
<span class="advice">2 |</span>     let x = SomeStruct::default();
  <span class="advice">|         - move occurs because `x` has type `SomeStruct`, which does not implement the `Copy` trait</span>
<span class="advice">3 |</span>     drop(x);
  <span class="advice">|          - value moved here</span>
<span class="advice">4 |</span>     drop(x);
  <span class="advice">|</span>          <span class="error">^ value used here after move</span>

For more information about this error, try `rustc --explain E0382`.
<span class="error">error</span>: could not compile `double-free` (bin "double-free") due to previous error
					</pre>
					<p><span class="rust">Rust</span> hates double free &mdash; compiler error ðŸ™Œ</p>
					<aside class="notes">
						Rust statically prevents the memory error called <em>double free</em>.<br>
						{wait 3s}<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Introducing borrowing. -->
				<section>
					<dl>
						<dt>Borrow</dt>
						<dd class="fragment">
							<span class="rust">Access</span> to a value <em>without</em> the obligation to destroy that value when it
							goes out of scope.
						</dd>
					</dl>
					<aside class="notes">
						But you don't have to give away ownership of a value to grant access to it. An owner can <em>lend</em> a
						value out;<br>
						&rarr;<br>
						or, reversing the viewpoint, another binding can <em>borrow</em> a value from its owner. Borrowing is
						different from ownership because it conveys capability to access, or even modify, a value but does not
						bestow the responsibility for destroying that value.<br>
						{wait 2s}<br>
						&rarr;<br>
					</aside>
				</section>
				
				<!-- Demonstrate borrowing. -->
				<section data-auto-animate="borrowing">
					<div>
						<pre style="font-size: medium"><code class="language-rust" data-trim data-line-numbers data-noescape>
struct Wrapped&lt;T&gt;(
	T // Owner of some `T`
);

enum Either&lt;'a, 'b, A, B&gt; {
	A(&'a A), // Immutable borrow of some `A` with lifetime 'a
	B(&'b B), // Immutable borrow of some `B` with lifetime 'b
}

fn main() {
	let w = Wrapped(5);        // Owner of `Wrapped(5)`
	let mut a = Either::A(&w); // Mutable owner of `Either`; `w` immutably borrowed
	f(&mut a);                 // `a` mutably borrowed, updated by call
} // `a` & `w` destroyed by end of block

fn f&lt;'a, A&gt;(
	e: &mut Either&lt;'a, 'a, A, A&gt; // Mutable borrow of some `Either`
) {
	*e = match e {
		Either::A(a) =&gt; // `a` owns borrow of `A`
			Either::B(a), // `e` becomes owner of new `Either`; `a` moved
		Either::B(b) =&gt; // `a` owns borrow of `A`
			Either::A(b)  // `e` becomes owner of new `Either`; `b` moved
	}
}
						</code></pre>
						<p>Borrowing</p>
					</div>
					<aside class="notes">
						Naturally, there are some important rules governing borrowed values, otherwise we wouldn't need a borrow
						checker!<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Rules of borrowing. -->
				<section data-auto-animate="borrowing">
					<div style="width: 50%; float: left">
						<pre style="font-size: medium"><code class="language-rust" data-trim data-line-numbers data-noescape>
struct Wrapped&lt;T&gt;(
	T // Owner of some `T`
);

enum Either&lt;'a, 'b, A, B&gt; {
	A(&'a A), // Immutable borrow of some `A` with lifetime 'a
	B(&'b B), // Immutable borrow of some `B` with lifetime 'b
}

fn main() {
	let w = Wrapped(5);        // Owner of `Wrapped(5)`
	let mut a = Either::A(&w); // Mutable owner of `Either`; `w` immutably borrowed
	f(&mut a);                 // `a` mutably borrowed, updated by call
} // `a` & `w` destroyed by end of block

fn f&lt;'a, A&gt;(
	e: &mut Either&lt;'a, 'a, A, A&gt; // Mutable borrow of some `Either`
) {
	*e = match e {
		Either::A(a) =&gt; // `a` owns borrow of `A`
			Either::B(a), // `e` becomes owner of new `Either`; `a` moved
		Either::B(b) =&gt; // `a` owns borrow of `A`
			Either::A(b)  // `e` becomes owner of new `Either`; `b` moved
	}
}
						</code></pre>
						<p>Borrowing</p>
					</div>
					<div style="margin-left: 50%">
						<p>Rules of borrowing:</p>
						<ul>
							<li>
								<em class="rust">Either</em> there may be <span class="rust">one</span> mutable borrow</li>
							<li class="fragment">
								<em class="rust">Or</em> there may be <span class="rust">zero</span> or <span class="rust">many</span>
								immutable borrows
							</li>
							<li class="fragment">
								References must refer to <span class="rust">live</span> values, i.e., <em>no dangling references</em>
							</li>
						</ul>
					</div>
					<aside class="notes">
						Firstly, there can be only one mutable borrower of some referenced value. So long as a mutable borrow
						exists, no other borrows can exist at all. And while the mutable borrow exists, even the owner cannot modify
						the underlying value. If you think of this in physical object terms, it makes perfect sense â€” how can you
						scribble in the margins of a book that you've lent out to a friend?<br>
						&rarr;<br>
						Secondly, so long as no mutable borrower exists, there can be many immutable borrowers of some referenced
						value. The physical analogy isn't straightforward here, because I usually can't lend the same book to each
						of my friends. Something to do with conservation of mass, I don't know. But fortunately, there's a good
						analogy from concurrent programming: read/write locks!<br>
						&rarr;<br>
						Lastly, references cannot outlive their owners. If they could, then they could become invalid by pointing to
						freed (and potentially reused) memory. But the borrow checker statically ensures that all borrows occur
						within the lexical scope of the owner. In other words, borrows have to go out of scope before or
						simultaneously with the owner. And just like that, Rust prohibits <em>dangling references</em> by
						construction.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Cheating the borrow checker: try #1. -->
				<section
						data-auto-animate="naive-borrow"
						data-background-color="#AD1210"
				>
					<div class="row">
						<div class="column" style="width: 50%; height: auto">
							<div>
								<pre style="font-size: medium"><code class="language-rust" data-trim data-line-numbers data-noescape>
	fn owner_dropped_while_borrowed() {
		let outer_borrow: &amp;i32;
		{
			let inner_borrow: &amp;i32;
			let owner: i32 = 10;
			inner_borrow = &amp;owner;
			outer_borrow = inner_borrow;
		}
		println!("heh, heh = {}", outer_borrow);
	}
								</code></pre>
								<p>Borrower, schmorrower</p>
							</div>
						</div>
						<img
							class="column"
							src="assets/Snidely%20Whiplash.svg"
							alt="Snidely Whiplash, trying to break Rust"
							style="width: 50%; height: auto">
					</div>
					<aside class="notes">
						But does it? Does it really? What happens if I do something sneaky, like this? Here, I've nested two scopes.
						Inside the inner scope is the hapless and doomed owner of the value `10`, as well as the creatively named
						<code>inner_borrow</code> of <code>owner</code>. But in the outer scope is the villainous
						<code>outer_borrow</code>, which tries to borrow <code>owner</code> indirectly through the unsuspecting
						<code>inner_borrow</code>. Since <code>owner</code> goes out of scope on line 8 and
						<code>outer_borrow</code> survives until line 10, <code>outer_borrow</code> should become a dangling
						reference after line 8.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Cheating the borrow checker: fail #1. -->
				<section
						data-auto-animate="naive-borrow"
						data-background-gradient="linear-gradient(to bottom, #FF474C, #8B47AC)"
				>
					<pre style="font-size: medium"><code class="language-rust" data-trim data-line-numbers data-noescape>
fn owner_dropped_while_borrowed() {
	let outer_borrow: &amp;i32;
	{
		let inner_borrow: &amp;i32;
		let owner: i32 = 10;
		inner_borrow = &amp;owner;
		outer_borrow = inner_borrow;
	}
	println!("heh, heh = {}", outer_borrow);
}
					</code></pre>
					<pre class="console" style="font-size: medium">
<span class="command">âžœ cargo build</span>
   <span class="command">Compiling</span> rust-presentation-2023-11-09 v0.1.0 (/naive-borrow)
<span class="error">error[E0597]</span>: `owner` does not live long enough
 <span class="advice">--></span> naive-borrow/src/main.rs:6:18
  <span class="advice">|</span>
<span class="advice">5 |</span>         let owner: i32 = 10;
  <span class="advice">|             ----- binding `owner` declared here</span>
<span class="advice">6 |</span>         inner_borrow = &amp;owner;
  <span class="advice">|</span>                        <span class="error">^^^^^^ borrowed value does not live long enough</span>
<span class="advice">7 |</span>         outer_borrow = inner_borrow;
<span class="advice">8 |</span>     }
  <span class="advice">|     - `owner` dropped here while still borrowed</span>
<span class="advice">9 |</span>     println!("heh, heh = {}", outer_borrow);
  <span class="advice">|                               ------------ borrow later used here</span>

For more information about this error, try `rustc --explain E0597`.
<span class="error">error</span>: could not compile `naive-borrow` (bin "naive-borrow") due to previous error
					</pre>
					<p>Curses, foiled again!</p>
					<aside class="notes">
						Is Rust going to stand for that? Nah, not really. The borrow checker noticed that owner didn't live long
						enough to accommodate the <code>outer_borrow</code>, so it forbade the assignment outright, even though it
						tried using <code>inner_borrow</code> as a patsy.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Cheating the borrow checker: try #2. -->
				<section
						data-auto-animate="sneaky-borrow"
						data-background-color="#AD1210"
				>
					<div class="row">
						<div class="column" style="width: 50%; height: auto">
							<div>
								<pre style="font-size: medium" data-id="code">
									<code class="language-rust" data-trim data-line-numbers data-noescape>
fn assign_through_borrow(
	a: &amp;mut &amp;i32,
	b: &amp;mut &amp;i32
) {
	*b = *a;
}

fn owner_dropped_while_borrowed() {
	let outer_owner = 10;
	let mut outer_borrow = &amp;outer_owner;
	{
		let inner_owner = 10;
		let mut inner_borrow = &amp;inner_owner;
		assign_through_borrow(
			&amp;mut inner_borrow,
			&amp;mut outer_borrow
		);
	}
	println!("heh, heh = {}", outer_borrow);
}
									</code>
								</pre>
								<p>Borrower, schmorrower</p>
							</div>
						</div>
						<img
								class="column"
								src="assets/Snidely%20Whiplash.svg"
								alt="Snidely Whiplash, trying to break Rust"
								style="width: 50%; height: auto">
					</div>
					<aside class="notes">
						But maybe we can get even more creative, by using an intermediate function call to disguise our perfidy.
						Here, we've introduced two owners, <code>outer_owner</code> and <code>inner_owner</code>, and initialized
						matching borrows, <code>outer_borrow</code> and <code>inner_borrow</code>. Nothing suspicious so far.
						<code>assign_to_borrow</code> looks innocent enough, too â€” it just does an assignment whose effect is
						visible in the caller. But the actual call of <code>assign_to_borrow</code> is super sketch â€” it mutably
						borrows <code>inner_borrow</code> and <code>outer_borrow</code> so that the callee can make
						<code>outer_borrow</code> point to <code>inner_owner</code>. Muahaha, dangling reference created! Suck it,
						Rust!<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Cheating the borrow checker: fail #2. -->
				<section
						data-auto-animate="sneaky-borrow"
						data-background-gradient="linear-gradient(to bottom, #FF474C, #8B47AC)"
				>
					<pre style="font-size: medium" data-id="code">
						<code class="language-rust" data-trim data-line-numbers data-noescape>
fn assign_through_borrow(
	a: &amp;mut &amp;i32,
	b: &amp;mut &amp;i32
) {
	*b = *a;
}
						</code>
					</pre>
					<pre class="console" style="font-size: medium">
<span class="command">âžœ cargo</span> build
   <span class="command">Compiling</span> sneaky-borrow v0.1.0 (/sneaky-borrow)
<span class="error">error</span>: lifetime may not live long enough
 <span class="advice">--></span> sneaky-borrow/src/main.rs:5:2
  <span class="advice">|</span>
<span class="advice">2 |</span>     a: &amp;mut &amp;i32,
  <span class="advice">|             - let's call the lifetime of this reference `'1`</span>
<span class="advice">3 |</span>     b: &amp;mut &amp;i32
  <span class="advice">|             - let's call the lifetime of this reference `'2`</span>
<span class="advice">4 |</span> ) {
<span class="advice">5 |</span>     *b = *a;
  <span class="advice">|</span>     <span class="error">^^^^^^^ assignment requires that `'1` must outlive `'2`</span>
  <span class="advice">|</span>
<span class="help">help</span>: consider introducing a named lifetime parameter
  <span class="advice">|</span>
<span class="advice">1</span> <span class="note">~</span> fn assign_through_borrow&lt;<span class="note">'a</span>>(
<span class="advice">2</span> <span class="note">~</span>     a: &amp;mut &amp;<span class="note">'a</span> i32,
<span class="advice">3</span> <span class="note">~</span>     b: &amp;mut &amp;<span class="note">'a</span> i32
  <span class="advice">|</span>

<span class="error">error</span>: could not compile `sneaky-borrow` (bin "sneaky-borrow") due to previous error
					</pre>
					<p>Curses, foiled again!</p>
					<aside class="notes">
						Wait, what's this? Rust won't compile <code>assign_to_borrow</code>! Curses, foiled again! But how did it
						know?<br>

						There's more to a borrow than its referent. There's also its <em>lifetime</em>. In other words, how long the
						borrow points to a live owner. In <em>any language</em>, a reference must not outlive its referent's owner,
						because that's how you get dangling references, yo. But in Rust, the compiler enables â€” nay, <em>forces</em>
						â€” you to get it right. The borrow checker statically tracks the lifetime of every borrow, and it does this
						by implicitly or explicitly attaching a lifetime through a built-in property. The property is expressed as a
						generic type parameter of the enclosing context; in this case, the function
						<code>assign_to_borrow</code>.<br>

						Now we can unpack the compiler's error message. The compiler forbade the redirection of <code>b</code>'s
						content to <code>a</code>'s content because it assumed that their lifetimes were unrelated. And in a vacuum,
						what else _could_ it assume? Most assumptions would be wrong in most circumstances, so Rust makes the most
						general possible assumption, thereby forcing us to clarify our intentions.<br>

						&rarr;<br>
					</aside>
				</section>

				<!-- Cheating the borrow checker: try #3. -->
				<section
						data-auto-animate="sneaky-borrow"
						data-background-color="#AD1210"
				>
					<div class="row">
						<div class="column" style="width: 50%; height: auto">
							<div>
								<pre style="font-size: medium" data-id="code">
									<code class="language-rust" data-trim data-line-numbers data-noescape>
fn annotated_assign_through_borrow&lt;
	'a: 'b,
	'b
&gt;(
	a: &amp;mut &amp;'a i32,
	b: &amp;mut &amp;'b i32,
) {
	*b = *a;
}

fn owner_dropped_while_borrowed() {
	let outer_owner = 10;
	let mut outer_borrow = &amp;outer_owner;
	{
		let inner_owner = 10;
		let mut inner_borrow = &amp;inner_owner;
		annotated_assign_through_borrow(
			&amp;mut inner_borrow,
			&amp;mut outer_borrow
		);
	}
	println!("heh, heh = {}", outer_borrow);
}
									</code>
								</pre>
								<p>Borrower, schmorrower</p>
							</div>
						</div>
						<img
								class="column"
								src="assets/Snidely%20Whiplash.svg"
								alt="Snidely Whiplash, trying to break Rust"
								style="width: 50%; height: auto">
					</div>
					<aside class="notes">
						Okay, let's make one last ditch effort to achieve villainy, because I don't know why. We're going to add two
						lifetime parameters to <code>assign_to_borrow</code>, one for each formal parameter. We'll name the
						lifetimes after the formal parameters themselves, out of convenience rather than syntactic necessity, and
						we're going to use a colon to say that <code>'a</code> outlives <code>'b</code>. That guarantees locally
						that we can perform the assignment.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Cheating the borrow checker: fail #3. -->
				<section
						data-auto-animate="sneaky-borrow"
						data-background-gradient="linear-gradient(to bottom, #FF474C, #8B47AC)"
				>
					<pre style="font-size: medium" data-id="code">
						<code class="language-rust" data-trim data-line-numbers data-noescape>
fn owner_dropped_while_borrowed() {
	let outer_owner = 10;
	let mut outer_borrow = &amp;outer_owner;
	{
		let inner_owner = 10;
		let mut inner_borrow = &amp;inner_owner;
		annotated_assign_through_borrow(
			&amp;mut inner_borrow,
			&amp;mut outer_borrow
		);
	}
	println!("heh, heh = {}", outer_borrow);
}
						</code>
					</pre>
					<pre class="console" style="font-size: medium">
<span class="command">âžœ cargo</span> build
   <span class="command">Compiling</span> sneaky-borrow-with-lifetime v0.1.0 (/sneaky-borrow-with-lifetime)
<span class="error">error[E0597]</span>: `inner_owner` does not live long enough
  <span class="advice">--></span> sneaky-borrow-with-lifetime/src/main.rs:13:26
   <span class="advice">|</span>
<span class="advice">12 |</span>         let inner_owner = 10;
   <span class="advice">|             ----------- binding `inner_owner` declared here</span>
<span class="advice">13 |</span>         let mut inner_borrow = &amp;inner_owner;
   <span class="advice">|</span>                                <span class="error">^^^^^^^^^^^^ borrowed value does not live long enough</span>
<span class="advice">...</span>
<span class="advice">18 |</span>     }
   <span class="advice">|     - `inner_owner` dropped here while still borrowed</span>
<span class="advice">19 |</span>     println!("heh, heh = {}", outer_borrow);
   <span class="advice">|                               ------------ borrow later used here</span>

For more information about this error, try `rustc --explain E0597`.
<span class="error">error</span>: could not compile `sneaky-borrow-with-lifetime` (bin "sneaky-borrow-with-lifetime")
due to previous error
					</pre>
					<p>Curses, foiled again!</p>
					<aside class="notes">
						You may already be able to guess why this won't work. And there it is, we're straight back to the original
						"problem". Now that we've told Rust the relationship between the lifetimes, it throws them right back in our
						face to defeat our insidious attempt to create a dangling reference. So â€¦ yeah. Rust really does prevent
						dangling references by construction. Pretty sweet, yeah?<br>

						But if the story ended here, then it would be an incomplete story. What we've seen is impressive, but it
						doesn't cover the gamut of memory access patterns. What about heap-resident values? What about shared
						ownership? What about cycles? More generally, what about situations where it's much harder to decide when a
						value should be destroyed? Well, Rust provides several smart pointer types that flesh out its memory safety
						story.<br>

						&rarr;<br>
					</aside>
				</section>

				<!-- Box. -->
				<section>
					<pre><code class="language-rust" data-trim data-noescape>
// Excerpted from standard library.
pub struct Box&lt;
		// Any type, even if size is statically unknown
    T: ?Sized,
		// To support "placement new"
    A: Allocator = Global
&gt;(Unique&lt;T&gt;, A); // `Unique` means "sole owner"
					</code></pre>
					<img
							src="assets/Box.svg"
							alt="Graph"
							style="width: 33%; height: auto"/>
					<p><code class="rust">Box</code></p>
					<aside class="notes">
						The simplest is <code>Box</code>, which simply designates a value that lives on the heap. By default, Rust
						allocates all values on the stack, but <code>Box</code> and other smart pointers maintain their referents on
						the heap. <code>Box</code> is usually the right choice for types whose instances vary in size.
						<code>Box</code> is generic over two type parameters: <code>T</code>, which represents the type on the heap;
						and <code>A</code>, the type of the allocator responsible for managing that heap. Usually you only care
						about <code>T</code>, but <code>A</code> is available for so-called "placement new" situations, Ã  la C++. In
						the vast majority of cases where you don't care, you don't have to mention A at all, and Rust will sensibly
						default it to the same type as the global allocator. There's no special magic here â€” like C++ and TypeScript
						and unlike Java, Kotlin, Scala, C#, and others, Rust supports default bindings for generic parameters. A
						<code>Box</code> is the sole owner of its content, so the content lives exactly as long as the
						<code>Box</code> does. When the <code>Box</code> goes out of scope, it and its contents are both
						destroyed.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Introduction to shared ownership. -->
				<section>
					<img
							src="assets/Graph%20no%20Rc.svg"
							alt="Graph"
							style="width: 33%; height: auto"/>
					<p>Who owns <code class="rust">E</code>?</p>
					<aside class="notes">
						The semantics of single ownership is nice and clean, but what if you have shared ownership? The classical
						example is a graph structure, where some nodes are held by multiple edges. Ownership of the nodes
						conceptually belongs to the whole graph, but usually the graph is a network of related objects, not a single
						object where ownership can be centralized. A natural enough approach is to share ownership of a node among
						its incoming edges, but how do we achieve this?<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Rc. -->
				<section>
					<pre><code class="language-rust" data-trim data-noescape>
// Simplified from standard library.
pub struct RcInner&lt;T: ?Sized&gt; {
	// Interiorly mutable strong count
	strong: Cell&lt;usize&gt;,
	// Interiorly mutable weak count (for cycle breaking)
	weak: Cell&lt;usize&gt;,
	// The shared value
	value: T
}

pub struct Rc&lt;T: ?Sized&gt; {
	// The shared value, plus reference counts
	inner: Box&lt;RcInner&lt;T&gt;&gt;
}
					</code></pre>
					<p>Simplified <code class="rust">Rc</code></p>
					<aside class="notes">
						<code>Rc</code> to the rescue. Rc stands for <em>reference counter</em>. <code>Rc</code> is really just a
						thin wrapper for a private kind of <code>Box</code> that places both the referent and the reference counter
						on the heap. This reference counter is incremented whenever the <code>Rc</code> is cloned, and decremented
						whenever the <code>Rc</code> goes out of scope. When the reference count goes to zero, the referent is
						destroyed. And because no <code>Rc</code> is outstanding, by definition, there are no dangling references to
						the defunct referent.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Graph with Rc. -->
				<section>
					<pre><code class="language-rust" data-trim data-noescape>
pub struct GraphNode&lt;T&gt; {
	// The payload
	value: T,
	// The vector of successors
	successors: Vec&lt;Rc&lt;GraphNode&lt;T&gt;&gt;&gt;
}
					</code></pre>
					<img
						src="assets/Graph%20With%20Rc.svg"
						alt="Graph with Rc"
						style="width: 33%; height: auto"/>
					<p>Shared Ownership with <code class="rust">Rc</code></p>
					<aside class="notes">
						Achievement unlocked: shared ownership!<br>

						So, what about mutating the referent of an <code>Rc</code>? Well, you can't. The private box inside is the
						real single owner of the shared data, and each <code>Rc</code> behaves like an immutable borrow of the box.
						If it didn't, then you could trivially violate the borrow checker's rule that each value can have at most
						one live mutable reference, which can lead to memory unsafety even in a single-threaded program.<br>

						So, does that mean that we can use <code>Rc</code> with multiple threads? Not quite, but we can use its
						concurrent cousin,<br>

						&rarr;<br>
					</aside>
				</section>

				<!-- Arc. -->
				<section>
					<pre><code class="language-rust" data-trim data-noescape>
// Simplified from standard library.
pub struct ArcInner&lt;T: ?Sized&gt; {
	// Atomically mutable strong count
	strong: atomic::AtomicUsize,
	// Atomically mutable weak count (for cycle breaking)
	weak: atomic::AtomicUsize,
	// The shared value
	value: T
}

pub struct Arc&lt;T: ?Sized&gt; {
	// The shared value, plus reference counts
	inner: Box&lt;ArcInner&lt;T&gt;&gt;
}
					</code></pre>
					<p>Simplified <code class="rust">Arc</code></p>
					<aside class="notes">
						<code>Arc</code>, which stands for <em>atomic reference counter</em>. <code>Arc</code> leverages special
						compiler intrinsics to ensure memory coherency in the presence of concurrent access, so it entails a bit
						more cost than <code>Rc</code>. This is one of several situations where Rust offers you a choice of
						abstractions, enabling you to right-size your choice based on your actual use case.<br>
						{wait 3s}<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Shared immutable data with Arc. -->
				<section data-background-gradient="linear-gradient(to bottom, #FF474C, #8B47AC)">
					<pre style="font-size: medium" data-id="code">
						<code class="language-rust" data-trim data-line-numbers data-noescape>
fn main() {
	let shared: Arc&lt;i32&gt; = Arc::new(10);
	let copy = Arc::clone(&shared);
	let forked = spawn(move || {
		println!("first thread: {}", *copy);
	});
	forked.join().unwrap();
	println!("main thread: {}", *shared);
}
						</code>
					</pre>
					<p>Share immutable data with <code class="rust">Arc</code></p>
					<aside class="notes">
						Armed with an <code>Arc</code>, you can now share a value between multiple threads and still be confident
						that it will be destroyed exactly once, as early as possible, without leaving a dangling reference behind.
						You still can't mutate the shared value, but we're getting closer. There are alternatives to concurrent data
						access patterns, of course â€” right, functional programmers? â€” and Rust enables numerous strategies, but dang
						it, sometimes it's convenient to mutate shared data rather than, I don't know, pass copies between
						threads.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Shared mutable data with Arc. -->
				<section data-background-gradient="linear-gradient(to bottom, #FF474C, #8B47AC)">
					<pre style="font-size: medium" data-id="code">
						<code class="language-rust" data-trim data-line-numbers data-noescape>
fn main() {
	let shared: Arc&lt;Mutex&lt;i32&gt;&gt; = Arc::new(Mutex::new(0));
	let join_handles: Vec&lt;JoinHandle&lt;()&gt;&gt; = (1..=10)
		.map(|_| { // Don't care about the subscript, only running 10 times
			let copy = Arc::clone(&shared);
			spawn(move || {
				let mut guarded_value: MutexGuard&lt;i32&gt; = copy.lock().unwrap();
				*guarded_value += 1;
			})
		})
		.collect();  // Iterators are lazy, so must collect
	// Wait for all threads to complete.
	join_handles.into_iter().for_each(|h| h.join().unwrap());
	println!("{}", *shared.lock().unwrap()); // Prints "10\n"
}
						</code>
					</pre>
					<p>Share mutable data with <code class="rust">Arc&lt;Mutex&gt;</code></p>
					<aside class="notes">
						Enter <code>Mutex</code>, the canonical mutual exclusion device from imperative programming. You can use the
						<code>lock</code> and <code>try_lock</code> methods to obtain a <code>MutexGuard</code>. Once you have a
						<code>MutexGuard</code>, it acts as an exclusive mutable reference to the protected value, so any code
						dynamically reachable from the lexical scope of the <code>MutexGuard</code> can access and mutate the
						protected value. When the <code>MutexGuard</code> goes out of scope, its destruction releases the exclusive
						hold, giving some other thread a turn to enter its own critical section. This is a textbook example of RAII
						â€” <em>Resource Acquisition Is Initialization</em>.<br>

						Now let's put it all together, literally. Start with our data, which might be of any type, so let's call it
						<code>T</code>. We need to ensure exclusive access in order to satisfy Rust's rules regarding mutation, so
						we wrap a <code>Mutex</code> around it to obtain <code>Mutex&lt;T&gt;</code>. And we want shared ownership,
						so we wrap an <code>Arc</code> around that to obtain an <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. We can clone
						the <code>Arc</code> to ratchet up the reference count, and use closures to transfer ownership of the copied
						smart pointer to another thread. When the last <code>Arc</code> goes out of scope, the <code>Mutex</code>
						and its protected value are both destroyed.<br>

						&rarr;<br>
					</aside>
				</section>

				<!-- Cheating the borrow checker: try #4. -->
				<section
						data-auto-animate="concurrent-rc"
						data-background-color="#AD1210"
				>
					<div class="row">
						<div class="column" style="width: 50%; height: auto">
							<div>
								<pre style="font-size: medium" data-id="code">
									<code class="language-rust" data-trim data-line-numbers data-noescape>
fn main() {
	let shared: Rc&lt;i32&gt; = Rc::new(10);
	let copy = Rc::clone(&shared);
	let forked = spawn(move ||
		{
			println!("first thread: {}", *copy);
		}
	);
	forked.join().unwrap();
	println!("main thread: {}", *shared);
}
									</code>
								</pre>
								<p>Borrower, schmorrower</p>
							</div>
						</div>
						<img
								class="column"
								src="assets/Snidely%20Whiplash.svg"
								alt="Snidely Whiplash, trying to break Rust"
								style="width: 50%; height: auto">
					</div>
					<aside class="notes">
						You may be wondering what keeps me from using an <code>Rc</code> with multiple threads, other than a
						craftsman's desire not to write bad code that breaks a product at runtime. Let's put the supervillain
						mustache back on for a moment. Surely, you can use an <code>Rc</code> instead of an <code>Arc</code> to
						break Rust at runtime, right? Obviously, it would be asking way too much to think that Rust could statically
						forbid data races, right? So much for Rust's vaunted memory safety guarantees, muahaha!<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Cheating the borrow checker: fail #4. -->
				<section
						data-auto-animate="concurrent-rc"
						data-background-gradient="linear-gradient(to bottom, #FF474C, #8B47AC)"
				>
					<pre style="font-size: medium" data-id="code">
						<code class="language-rust" data-trim data-line-numbers data-noescape>
fn main() {
	let shared: Rc&lt;i32&gt; = Rc::new(10);
	let copy = Rc::clone(&shared);
	let forked = spawn(move ||
		{
			println!("first thread: {}", *copy);
		}
	);
	forked.join().unwrap();
	println!("main thread: {}", *shared);
}
						</code>
					</pre>
					<pre class="console" style="font-size: x-small">
<span class="command">âžœ cargo</span> build
   <span class="command">Compiling</span> concurrent-rc v0.1.0 (/concurrent-rc)
<span class="command">error[E0277]</span>: `Rc&lt;i32&gt;` cannot be sent between threads safely
   <span class="advice">--></span>; concurrent-rc/src/main.rs:7:21
    <span class="advice">|</span>
<span class="advice">7   |</span>       let forked = spawn(move ||
<span class="advice">    |                    -----</span> <span class="error">^</span><span class="advice">------</span>
<span class="advice">    |                    |</span>     <span class="error">|</span>
    <span class="advice">|</span>  <span class="error">__________________</span><span class="advice">|</span><span class="error">_____</span><span class="advice">within this `[closure@concurrent-rc/src/main.rs:7:21: 7:28]`</span>
    <span class="advice">|</span> <span class="error">|</span>                  <span class="advice">|</span>
    <span class="advice">|</span> <span class="error">|</span>                  <span class="advice">required by a bound introduced by this call</span>
<span class="advice">8   |</span> <span class="error">|</span>         {
<span class="advice">9   |</span> <span class="error">|</span>             println!("first thread: {}", *copy);
<span class="advice">10  |</span> <span class="error">|</span>         }
    <span class="advice">|</span> <span class="error">|_________^ `Rc&lt;i32&gt;` cannot be sent between threads safely</span>
    <span class="advice">|</span>
    <span class="advice">=</span> <strong>help</strong>: within `[closure@concurrent-rc/src/main.rs:7:21: 7:28]`, the trait `Send` is not implemented for `Rc&lt;i32&gt;`
<span class="note">note</span>: required because it's used within this closure
   <span class="advice">--></span> concurrent-rc/src/main.rs:7:21
    <span class="advice">|</span>
<span class="advice">7   |</span>     let forked = spawn(move ||
    <span class="advice">|</span>                        <span class="note">^^^^^^^</span>
<span class="note">note</span>: required by a bound in `spawn`
   <span class="advice">--></span> /lib/rustlib/src/rust/library/std/src/thread/mod.rs:680:8
    <span class="advice">|</span>
<span class="advice">680 |</span>     F: Send + 'static,
    <span class="advice">|</span>        <span class="note">^^^^ required by this bound in `spawn`</span>

For more information about this error, try `rustc --explain E0277`.
<span class="error">error</span>: could not compile `concurrent-rc` (bin "concurrent-rc") due to previous error
					</pre>
					<p>Curses, foiled again!</p>
					<aside class="notes">
						Huh, looks like the fuzz caught us again. "Rc&lt;i32&gt; cannot be sent between threads safely," because
						"the trait Send is not implemented for Rc&lt;i32&gt;." Other than, "curses, foiled again," what does this
						mean? It all comes down to how Rust knows that it's legal to transfer ownership of an <code>Arc</code> to
						another thread but not an <code>Rc</code>.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Introduction to traits. -->
				<section>
					<p>Traits in <span class="rust">Rust:</span></p>
					<ul>
						<li class="fragment" data-fragment-index="1">Like interfaces in Java, Kotlin</li>
						<li class="fragment" data-fragment-index="1">Like traits in Scala</li>
						<li class="fragment" data-fragment-index="1">Like type classes in Haskell</li>
						<li class="fragment" data-fragment-index="2">May prescribe one or more methods</li>
						<li class="fragment" data-fragment-index="2">May provide default implementations of methods</li>
						<li class="fragment" data-fragment-index="3">May not specify state</li>
					</ul>
					<aside class="notes">
						<em>Traits</em> in Rust are analogous to<br>
						&rarr;<br>
						interfaces in Java and Kotlin, traits in Scala, and type classes in Haskell.<br>
						&rarr;<br>
						A trait specifies a behavioral contract that any conformant types have to implement. The contract can
						include default implementations for one or more methods,<br>
						&rarr;<br>
						but cannot directly specify any state. When instantiating a trait for a concrete type, the compiler copies
						down any default methods that were not overridden, complements them with overrides and explicit
						implementations of abstract methods, and verifies that all behavior is covered. This is all well and good,
						and not too interesting. What's interesting in this regard is Rust's handful of magical marker traits.
						Markers statically ascribe interesting properties to types, and thus inform the compiler's semantic
						validation and code generation.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- The Send trait. -->
				<section>
					<dl>
						<dt><code class="rust">Send</code></dt>
						<dd class="fragment">
							Auto trait that denotes types that can be <span class="rust">moved</span> across thread boundaries<br>
							<em class="fragment">(because they are not subject to data races)</em>
						</dd>
					</dl>
					<aside class="notes">
						Let's return to the concrete problem that sent us down the trait rabbit hole, the <code>Send</code>
						trait.<br>

						&rarr;<br>
						The <code>Send</code> trait does not specify any methods, but instead specifies that conformant types may be
						transferred<br>

						&rarr;<br>
						safely across thread boundaries.<br>

						&rarr;<br>
					</aside>
				</section>

				<!-- Cheating the borrow checker: fail #4, redux. -->
				<section
						data-auto-animate="concurrent-rc"
						data-background-gradient="linear-gradient(to bottom, #FF474C, #8B47AC)"
				>
					<pre style="font-size: medium" data-id="code">
						<code class="language-rust" data-trim data-line-numbers data-noescape>
fn main() {
	let shared: Rc&lt;i32&gt; = Rc::new(10);
	let copy = Rc::clone(&shared);
	let forked = spawn(move ||
		{
			println!("first thread: {}", *copy);
		}
	);
	forked.join().unwrap();
	println!("main thread: {}", *shared);
}
						</code>
					</pre>
					<pre class="console" style="font-size: x-small">
<span class="command">âžœ cargo</span> build
   <span class="command">Compiling</span> concurrent-rc v0.1.0 (/concurrent-rc)
<span class="command">error[E0277]</span>: `Rc&lt;i32&gt;` cannot be sent between threads safely
   <span class="advice">--></span>; concurrent-rc/src/main.rs:7:21
    <span class="advice">|</span>
<span class="advice">7   |</span>       let forked = spawn(move ||
<span class="advice">    |                    -----</span> <span class="error">^</span><span class="advice">------</span>
<span class="advice">    |                    |</span>     <span class="error">|</span>
    <span class="advice">|</span>  <span class="error">__________________</span><span class="advice">|</span><span class="error">_____</span><span class="advice">within this `[closure@concurrent-rc/src/main.rs:7:21: 7:28]`</span>
    <span class="advice">|</span> <span class="error">|</span>                  <span class="advice">|</span>
    <span class="advice">|</span> <span class="error">|</span>                  <span class="advice">required by a bound introduced by this call</span>
<span class="advice">8   |</span> <span class="error">|</span>         {
<span class="advice">9   |</span> <span class="error">|</span>             println!("first thread: {}", *copy);
<span class="advice">10  |</span> <span class="error">|</span>         }
    <span class="advice">|</span> <span class="error">|_________^ `Rc&lt;i32&gt;` cannot be sent between threads safely</span>
    <span class="advice">|</span>
    <span class="advice">=</span> <strong>help</strong>: within `[closure@concurrent-rc/src/main.rs:7:21: 7:28]`, the trait `Send` is not implemented for `Rc&lt;i32&gt;`
<span class="note">note</span>: required because it's used within this closure
   <span class="advice">--></span> concurrent-rc/src/main.rs:7:21
    <span class="advice">|</span>
<span class="advice">7   |</span>     let forked = spawn(move ||
    <span class="advice">|</span>                        <span class="note">^^^^^^^</span>
<span class="note">note</span>: required by a bound in `spawn`
   <span class="advice">--></span> /lib/rustlib/src/rust/library/std/src/thread/mod.rs:680:8
    <span class="advice">|</span>
<span class="advice">680 |</span>     F: Send + 'static,
    <span class="advice">|</span>        <span class="note">^^^^ required by this bound in `spawn`</span>

For more information about this error, try `rustc --explain E0277`.
<span class="error">error</span>: could not compile `concurrent-rc` (bin "concurrent-rc") due to previous error
					</pre>
					<p>ðŸ¤”</p>
					<aside class="notes">
						<code>Rc</code> does not implement Send, so the compiler forbids it from being captured by the closure
						passed to spawn. But <code>Arc</code> does implement <code>Send</code>, so Rust allows it.<br>

						{wait 3s}<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Cheating the borrow checker: try #5. -->
				<section
						data-auto-animate="concurrent-rc"
						data-background-color="#AD1210"
				>
					<div class="row">
						<div class="column" style="width: 50%; height: auto">
							<div>
								<pre style="font-size: medium" data-id="code">
									<code class="language-rust" data-trim data-line-numbers data-noescape>
fn main() {
	let shared: Arc&lt;Rc&lt;i32&gt;&gt; =
		Arc::new(Rc::new(10));
	let copy = Arc::clone(&shared);
	let forked = spawn(move ||
		{
			println!("first thread: {}", **copy);
		}
	);
	forked.join().unwrap();
	println!("main thread: {}", **shared);
}
									</code>
								</pre>
								<p>Borrower, schmorrower</p>
							</div>
						</div>
						<img
								class="column"
								src="assets/Snidely%20Whiplash.svg"
								alt="Snidely Whiplash, trying to break Rust"
								style="width: 50%; height: auto">
					</div>
					<aside class="notes">
						Okay, let's try one more technique to cheat the compiler. Maybe we can embed an <code>Rc</code> within an
						<code>Arc</code> in order to bypass Rust's borrow checker.<br>
						{wait 7s}<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Cheating the borrow checker: fail #5. -->
				<section
						data-auto-animate="concurrent-rc"
						data-background-gradient="linear-gradient(to bottom, #FF474C, #8B47AC)"
				>
					<pre style="font-size: medium" data-id="code">
						<code class="language-rust" data-trim data-line-numbers data-noescape>
fn main() {
	let shared: Arc&lt;Rc&lt;i32&gt;&gt; =
		Arc::new(Rc::new(10));
	let copy = Arc::clone(&shared);
	let forked = spawn(move ||
		{
			println!("first thread: {}", **copy);
		}
	);
	forked.join().unwrap();
	println!("main thread: {}", **shared);
}
						</code>
					</pre>
					<pre class="console" style="font-size: x-small">
<span class="command">âžœ cargo</span> build
   <span class="command">Compiling</span> concurrent-rc-in-arc v0.1.0 (/concurrent-rc-in-arc)
<span class="error">error[E0277]</span>: `Rc&lt;i32&gt;` cannot be shared between threads safely
   <span class="advice">--></span> concurrent-rc-in-arc/src/main.rs:8:21
    <span class="advice">|</span>
<span class="advice">8   |</span>       let forked = spawn(move ||
    <span class="advice">|</span>  <span class="error">__________________</span><span class="advice">-----</span><span class="error">_^</span>
    <span class="advice">|</span> <span class="error">|</span>                  <span class="advice">|</span>
    <span class="advice">|</span> <span class="error">|</span>                  <span class="advice">required by a bound introduced by this call</span>
<span class="advice">9   |</span> <span class="error">|</span>         {
<span class="advice">10  |</span> <span class="error">|</span>             println!("first thread: {}", **copy);
<span class="advice">11  |</span> <span class="error">|</span>         }
    <span class="advice">|</span> <span class="error">|_________^ `Rc&lt;i32&gt;` cannot be shared between threads safely</span>
    <span class="advice">|</span>
    <span class="advice">=</span> <strong>help</strong>: the trait `Sync` is not implemented for `Rc&lt;i32&gt;`
    <span class="advice">=</span> <strong>note</strong>: required for `Arc&lt;Rc&lt;i32&gt;&gt;` to implement `Send`
<span class="note">note</span>: required because it's used within this closure
   <span class="advice">--></span> concurrent-rc-in-arc/src/main.rs:8:21
    <span class="advice">|</span>
<span class="advice">8   |</span>     let forked = spawn(move ||
    <span class="advice">|</span>                        <span class="note">^^^^^^^</span>
<span class="note">note</span>: required by a bound in `spawn`
   <span class="advice">--></span> /lib/rustlib/src/rust/library/std/src/thread/mod.rs:680:8
    <span class="advice">|</span>
<span class="advice">680 |</span>     F: Send + 'static,
    <span class="advice">|</span>        <span class="note">^^^^ required by this bound in `spawn`</span>
    <span class="rust">â€¦</span>

For more information about this error, try `rustc --explain E0277`.
<span class="error">error</span>: could not compile `concurrent-rc-in-arc` (bin "concurrent-rc-in-arc") due to previous error
					</pre>
					<p>Curses, foiled again!</p>
					<aside class="notes">
						Butâ€¦ no. "Rc&lt;i32&gt; cannot be shared between threads safely," because "the trait Sync is not implemented
						for Rc&lt;i32&gt;".<br>
						{wait 7s}<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- The Sync trait. -->
				<section>
					<dl>
						<dt><code class="rust">Sync</code></dt>
						<dd class="fragment">
							Auto trait that denotes types that can be <span class="rust">shared</span> across thread boundaries<br>
							<em class="fragment">(because they are not subject to data races)</em>
						</dd>
					</dl>
					<aside class="notes">
						<code>Sync</code> is another marker trait.<br>
						&rarr;<br>
						When a type implements <code>Sync</code>, its instances are permitted to be<br>
						&rarr;<br>
						shared between threads.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Rules for Send and Sync. -->
				<section data-auto-animate="rules-send-sync">
					<div class="r-stack">
						<img
								class="fragment major-fade-out"
								src="assets/Spy%20Shhh.png"
								alt="Spy Shhh"
								style="width: 60%; height: auto"
								data-fragment-index="1">
						<div>
							<p class="fragment" data-fragment-index="1">
								Rules for <code class="rust">Send</code> and <code class="rust">Sync</code>
							</p>
							<p class="fragment" style="margin-top: -20px; font-size: medium" data-fragment-index="1">
								(which I am <em>definitely</em> not talking about in this presentation)
							</p>
							<ul class="fragment" style="font-size: large" data-fragment-index="1">
								<li>A type is <code class="rust">Send</code> <em>iff</em> it is safe to move to another thread.</li>
								<li>A type is <code class="rust">Sync</code> <em>iff</em> it is safe to share with other threads.</li>
								<li>
									<code class="rust">T</code> is <code class="rust">Sync</code> <em>iff</em> <code class="rust">&T</code>
									is <code class="rust">Send</code>.
								</li>
								<li>
									A compound type that is composed entirely of <code class="rust">Send</code> or
									<code class="rust">Sync</code> types, then it is <code class="rust">Send</code> or
									<code class="rust">Sync</code>.
								</li>
								<li>
									Raw pointers (<code class="rust">*const T</code> and <code class="rust">*mut T</code> are neither
									<code class="rust">Send</code> nor <code class="rust">Sync</code>.
								</li>
								<li>
									<code class="rust">Cell</code>, <code class="rust">RefCell</code>, and
									<code class="rust">UnsafeCell</code> are not <code class="rust">Sync</code>.
								</li>
								<li>
									<code class="rust">Rc</code> is not <code class="rust">Send</code> or <code class="rust">Sync</code>! ðŸ˜€
								</li>
							</ul>
						</div>
					</div>
					<aside class="notes">
						<code>Send</code> and <code>Sync</code> are both _auto traits_: they are automatically implemented by the
						compiler whenever they apply, so they automatically apply to most immutable primitive data â€” booleans,
						integers, and floats. For composite types, like <code>structs</code> and <code>enums</code>, Rust looks at
						the fields and variants of the type to decide whether the type itself is <code>Send</code> or
						<code>Sync</code>.<br>
						&rarr;<br>
						The rules are a bit complex, so I won't go into them here. But you can wrap types that don't implement
						<code>Send</code> or <code>Sync</code> in synchronized types like <code>Mutex</code> or <code>RwLock</code>,
						which do implement <code>Send</code> and <code>Sync</code>, thereby allowing transfer or sharing with other
						threads.<br>
						But <code>Rc&lt;T&gt;</code> doesn't implement <code>Sync</code>, so
						<code>Arc&lt;Rc&lt;T&gt;&gt;</code> also doesn't implement <code>Sync</code>. Therefore, it's impossible to
						share an <code>Arc&lt;Rc&lt;T&gt;&gt;</code> with another thread. Once again, Rust has statically ensured
						memory safety.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Memory safety in Rust. -->
				<section data-background-gradient="linear-gradient(to bottom, #FF474C, #8B47AC)">
					<h1>MEMORY SAFETY<br> <code>==</code><br> THREAD SAFETY</h1>
					<p class="fragment custom fade-blur">(in Rust ðŸ¦€ !)</p>
					<aside class="notes">
						Now that we're talking about concurrent programming, though, a new observation emerges. Memory safety
						<em>is</em> thread safety.<br>
						&rarr;<br>
						Rust ensures memory safety statically, and because it includes deep primitive support for ensuring memory
						safety across thread boundaries, via <code>Send</code>, <code>Sync</code>, and other mechanisms, it
						<em>also</em> statically protects against data races.<br> Unless you resort to really weird patterns with
						unsafe code or foreign function calls, Rust guarantees that any memory safe program is also free of data
						races. This is a unique selling point for Rust, folks. As of Q4 2023, no other programming language can
						claim to achieve this effect in quite this way. Rust's deep memory safety enables what the official Rust
						book aptly likes to call <em>fearless concurrency</em>.<br>
						I focused this talk around Rust's memory model, because in many ways, this _is_ the real novelty. Rust has a
						lot of cool features â€” zero-cost abstractions, immutability by default, algebraic data types, pattern
						matching, higher-order functions, type deduction through unification based on a variant of the
						Hindley-Milner algorithm, traits with associated type parameters, object-oriented programming through trait
						objects, interior mutability, metaprogramming through macros, asynchronous I/O â€” but its deeply reasoned and
						superbly architected memory model is the heart and soul of Rust. It secures Rust's place in the pantheon of
						systems programming languages: safe, fast, supreme.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Official Rust resources. -->
				<section data-visibility="uncounted">
					<p>Official <span class="rust">Rust</span> resources:</p>
					<ul>
						<li>
							<a href="https://www.rust-lang.org/" target="_blank" rel="noopener noreferrer">
								Rust: Official Website
							</a>
						</li>
						<li>
							<a href="https://crates.io/" target="_blank" rel="noopener noreferrer">
								Crates.io: Official Crate Registry
							</a>
						</li>
						<li>
							<a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener noreferrer">
								The Rust Programming Language: Online Book
							</a>
						</li>
						<li>
							<a href="https://doc.rust-lang.org/reference/" target="_blank" rel="noopener noreferrer">
								The Rust Reference: Online Book
							</a>
						</li>
						<li>
							<a href="https://doc.rust-lang.org/nomicon/" target="_blank" rel="noopener noreferrer">
								The Rustonomicon: Online Book
							</a>
						</li>
						<li>
							<a href="https://users.rust-lang.org/" target="_blank" rel="noopener noreferrer">
								Users forum
							</a>
						</li>
					</ul>
					<aside class="notes">
						I truly hope that you enjoyed our time together today. I will make a transcript of this presentation, as
						well as the companion slide deck, generally available to anyone who's interested.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Community Rust resources. -->
				<section data-visibility="uncounted">
					<p>Community <span class="rust">Rust</span> resources:</p>
					<ul>
						<li>
							<a href="https://www.jetbrains.com/rust/" target="_blank" rel="noopener noreferrer">
								RustRover: JetBrains IDE for Rust
							</a>
						</li>
						<li>
							<a href="https://code.visualstudio.com/docs/languages/rust" target="_blank" rel="noopener noreferrer">
								Rust in Visual Studio Code
							</a>
						</li>
						<li>
							<a href="https://discord.com/invite/rust" target="_blank" rel="noopener noreferrer">
								Rust on Discord
							</a>
						</li>
						<li>
							<a href="https://github.com/omarabid/rust-companies" target="_blank" rel="noopener noreferrer">
								Companies using Rust
							</a>
						</li>
						<li>
							<a href="https://github.com/rust-unofficial/awesome-rust" target="_blank" rel="noopener noreferrer">
								Awesome Rust: Curated Crate List
							</a>
						</li>
					</ul>
					<aside class="notes">
						At the back of the slide deck, you will find resources to ease newcomers into Rust development: websites,
						books, IDEs, libraries, forums, and so forth. I will open the meeting for questions and answers.<br>
						&rarr;<br>
					</aside>
				</section>

				<!-- Internal Rust resources. -->
				<section data-visibility="uncounted">
					<p>Internal Xebia Functional <span class="rust">Rust</span> resources:</p>
					<ul>
						<li>
							<a
									href="https://xebiagroup.sharepoint.com/:w:/r/sites/xf/_layouts/15/Doc.aspx?sourcedoc=%7B2E6B8E20-1458-4F78-AF2F-7F6DCDBBC2AB%7D&file=Third-Party%20Crates.docx&action=default&mobileredirect=true"
									target="_blank"
									rel="noopener noreferrer"
							>
								Crates used by our team
							</a>
						</li>
						<li>
							<a href="https://fortyseven.slack.com/archives/CDZU8MC3F" target="_blank" rel="noopener noreferrer">
								#rust: Rust on Slack
							</a>
						</li>
						<li>
							<a href="SET-REAL-LOCATION" target="_blank" rel="noopener noreferrer">
								This recorded presentation
							</a>
						</li>
						<li>
							<a href="https://47degrees.github.io/rust-2023-11-09/" target="_blank" rel="noopener noreferrer">
								This slide deck on GitHub Pages
							</a>
						</li>
						<li>
							<a href="https://xebiagroup.sharepoint.com/:w:/r/sites/xf/_layouts/15/Doc.aspx?sourcedoc=%7BB42101F0-D789-49C4-B219-0E59966290AE%7D&file=Rust%20Talk%202023.11.09.docx&action=default&mobileredirect=true" target="_blank" rel="noopener noreferrer">
								Original script for this presentation
							</a>
						</li>
					</ul>
					<p>Please request access if you don't have it!</p>
					<aside class="notes">
						If you have access to Slack, you can also reach out on #rust, and I will be happy to talk about the language
						or its ecosystem, and I'll do my best to answer any questions.<br>
						&rarr;<br>
					</aside>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script src="plugin/highlight/rust.js"></script>
		<script src="plugin/mermaid/mermaid.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			// noinspection JSUnresolvedReference
			Reveal.initialize({
				hash: true,
				highlight: {
					beforeHighlight: h => h.registerLanguage("rust", rust)
				},
				slideNumber: "c/t",

				mermaid: {
					theme: "dark",
					themeVariables: {
						darkMode: true
					}
				},

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMermaid ]
			});
		</script>
	</body>
</html>
